push dword pattern				;
push dword string				;
call match						;
add esp, 8						;

match:							; BEGINING of SUBPROGRAM
		push ebp				; организуем стековый фрейм
		mov ebp, esp			; передаем значение указателя esp в ebp, чтобы 
								; пользоваться esp дальше
		sub esp, 4				; резервируем место под локальную переменную I
								; I будет по адресу [ebp - 4]
		push esi				; сохраняем значение регистра ESI в стек 
								; (чтобы потом восстановить)
		push edi				; сохраняем значение регистра EDI в стек 
								; (чтобы потом восстановить)
		mov esi, [ebp + 8]		; загружаем пар-р из стека: адрес строки в esi
		mov edi, [ebp + 12]		; загружаем пар-р из стека: адрес образца в edi

.again:							; локальная метка (сюда вернемся, когда
								; сопоставим очередной символ и сдвинемся)
		cmp byte [edi], 0		; образец кончился?
		jne .not_end			; если нет - прыгаем
		cmp	byte [esi], 0		; образец кончился. А строка?
		jne near .false			; если нет, то вернуть ЛОЖЬ
		jmp .true				; кончились одновременно: ИСТИНА

.not_end:						; если образец не кончился...
		cmp byte [edi], '*'		; не звездочка ли в начале образца?
		jne .not_star			; если нет - прыгаем отсюда в not_star
								; звёздочка! организуем цикл
		mov dword [ebp - 4], 0	; I = 0

.star_loop:
								; готовимся к рекурсивному вызову
								; засовываем в стек второй и первый агрумент
		mov eax, edi			; сначала второй аргумент - образец. помещаем
								; в регистр EAX
		inc eax					; в регистр EAX, смотр. со след. сим. (после *)
		push eax
		mov eax, esi			; первый аргумент в стек: строка ESI через EAX
		add eax, [ebp - 4]		; строка с I-ого символа - прибавляем I=[ebp-4]
		push eax
		call match				; вызываем сами себя, но с новыми параметрами
		add esp, 8				; после вызова match очищаем стек

		test eax, eax			; что нам вернули в EAX?
		jnz .true				; вернули не ноль, т.е. ИСТИНУ значит остаток
								; строки сопоставился с остатком образца =>
								; => вернем ИСТИНУ
		add eax, [ebp - 4]		; вернули 0, т.е. ЛОЖЬ. Надо попробовать
								; больше символов "списать" на эту звездочку
								; добавляем к EAX значение I для след.проверки:
		cmp byte [esi + eax], 0	; НО сначала проверим, не кончилась ли строка?
		je .false				; строка кончилась => тогда точно ЛОЖЬ
		inc	dword [ebp - 4]		; иначе пробуем I = I + 1
		jmp .star_loop			;		и прыгаем в начало цикла по I

.not_star:						; сюда мы попали, если образец не пуст
		mov al, [edi]			; и образец не начинается с '*'
		cmp al, '?'				; может быть, там знак '?'
		je .quest				; если да, прыгаем отсюда
		cmp al, [esi]			; если нет, символы в начале строки и образца
								; должны совпадать; если строка кончилась
								; эта проверка тоже не пройдет
		jne .false				; не совпали (или конец строки) => возвр. ЛОЖЬ
		jmp .goon				; совпали - продалжаем просмотр

.quest:
		cmp byte [esi], 0		; надо только, чтобы строка не кончилась
		jz .false				; если строка кончилась - возвращаем ЛОЖЬ
.goon:	inc esi					; символы сопоставились => сдвигаемся по строке
		inc edi					; и по образцу
		jmp .again				; и продолжаем
.true:
		mov eax, 1				; 1
		jmp .quit
.false:
		xor eax, eax			; 0
.quit:
		pop edi					; восстанав. исходное значение регистра EDI
		pop esi					; восстанав. исходное значение регистра ESI
		mov esp, ebp			; возвращаем указатель ESP на вершину стека
		pop ebp					; восстанав. исходное значение регистра EBP
		ret						; возвращаемся в осн.прогу по адресу возврата
